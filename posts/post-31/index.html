<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Установка и настройка Grbl - urpylka</title><link rel="icon" type="image/x-icon" href="https://urpylka.com/favicon.ico" />
	<link rel="apple-touch-icon" sizes="57x57" href="https://urpylka.com/favicon/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="https://urpylka.com/favicon/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="https://urpylka.com/favicon/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="https://urpylka.com/favicon/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="https://urpylka.com/favicon/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="https://urpylka.com/favicon/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="https://urpylka.com/favicon/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="https://urpylka.com/favicon/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="https://urpylka.com/favicon/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="https://urpylka.com/favicon/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="https://urpylka.com/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="https://urpylka.com/favicon/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="https://urpylka.com/favicon/favicon-16x16.png">
	<link rel="manifest" href="https://urpylka.com/favicon/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="https://urpylka.com/favicon/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1"><meta itemprop="name" content="Установка и настройка Grbl">
<meta itemprop="description" content="После пересборки станка в него была установлена Arduino Uno c CNC Shield. Тк драйвера не стандартные типа A4988, возникли проблемы. В статье изложены возникшие проблемы и их решение, а также описания настроек Grbl.">
<meta itemprop="datePublished" content="2021-05-06T20:15:01&#43;04:00" />
<meta itemprop="dateModified" content="2021-05-06T20:15:01&#43;04:00" />
<meta itemprop="wordCount" content="4683">



<meta itemprop="keywords" content="ru,cnc,diy," /><meta property="og:title" content="Установка и настройка Grbl" />
<meta property="og:description" content="После пересборки станка в него была установлена Arduino Uno c CNC Shield. Тк драйвера не стандартные типа A4988, возникли проблемы. В статье изложены возникшие проблемы и их решение, а также описания настроек Grbl." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://urpylka.com/posts/post-31/" />
<meta property="article:published_time" content="2021-05-06T20:15:01+04:00" />
<meta property="article:modified_time" content="2021-05-06T20:15:01+04:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Установка и настройка Grbl"/>
<meta name="twitter:description" content="После пересборки станка в него была установлена Arduino Uno c CNC Shield. Тк драйвера не стандартные типа A4988, возникли проблемы. В статье изложены возникшие проблемы и их решение, а также описания настроек Grbl."/>
<link rel="stylesheet" type="text/css" media="screen" href="https://urpylka.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://urpylka.com/css/main.css" />
	<link rel="stylesheet" type="text/css" id="dark-scheme" href="https://urpylka.com/css/dark.css" />
	<link rel="stylesheet" type="text/css" href="https://urpylka.com/css/medium-font.css" />
<script type="text/javascript" >
	(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
	m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
	(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
ym("62022457", "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/62022457" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-163829261-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script><script src="https://urpylka.com/js/main.js"></script></head>


<body>
    <div class="container wrapper">
        <div class="header"><div class="avatar">
		<a href="https://urpylka.com/">
			<img src="/img/artem.jpg" alt="urpylka" />
		</a>
	</div><div class="flex-block">
		<h1 class="site-title"><a href="https://urpylka.com/">urpylka</a></h1>
		<nav class="nav ico">
			<ul class="flat"><li><a href="https://github.com/urpylka" title="Github"><i data-feather="github"></i></a></li><li><a href="https://instagram.com/urpylka" title="Instagram"><i data-feather="instagram"></i></a></li><li class="edge-left"><span class="scheme-toggle"><a href="#" id="scheme-toggle"></a></span></li>
			</ul>
		</nav>
	</div><p id="subtitle">Programming, robotics, traveling</p><nav class="nav menu">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">Posts</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


        <div class="post one">
            <div class="post-header">
                
                <div class="meta">
                    <div class="date">
                        <span class="day">06</span>
                        <span class="rest">May 2021</span>
                    </div>
                </div>
                
                <div class="matter">
                    <h1 class="title">Установка и настройка Grbl</h1>
                </div>
            </div>

            <div class="markdown">
                <hr>
<p>Навигация по проекту:</p>
<ol>
<li><a href="/posts/post-19/">Покупка и разбор фрезерного станка Cutmaster CM-1500</a></li>
<li><a href="/posts/post-30/">Модернизация Cutmaster CM-1500</a></li>
<li><a href="/posts/post-31/">Установка и настройка Grbl</a></li>
<li><a href="/posts/post-35/">CNCjs + ESP-Link</a></li>
<li><a href="/posts/post-36/">Grbl + ESC &amp; Brushless motor</a></li>
</ol>
<hr>
<h2 id="почему-grbl">Почему Grbl?</h2>
<p>В плане выбора прошивок я рассматривал легкие opensource проекты. А в качестве контроллера изначально тыкнул пальцем в Arduino Uno просто потому что это самое дешевое и простое решение. И я хочу доказать, что даже оно на голову круче чем вариант со старым компом с LPT портом, который использовался на моем станке раньше.</p>
<p>На 8-битный мк Atmega328p который используется в Arduino Uno самыми известными прошивками являются Marlin и Grbl. При этом Marlin давно разросся и начиная со второй версии уже не подходит на 8-битные мк. В тоже время Grbl поддерживается по сей день и является узким и производительным решением под 8-битный AVR контроллер.</p>
<h2 id="установка">Установка</h2>
<p>Проект Grbl раньше распологался в репозитории <a href="https://github.com/grbl/grbl">github.com/grbl/grbl</a>, но сейчас переехал в <a href="https://github.com/gnea/grbl">github.com/gnea/grbl</a>. На сколько я понимаю, это обусловлено смещением фокуса на главный продукт – G-code парсер <a href="https://github.com/gnea/gnea">gnea</a>.</p>
<p>Прошивку можно скачать из вкладки релизы в репозитории в виде hex-файла или собрать самому с помощью <code>Makefile</code>.</p>
<p>Для загрузки на мк необходимо воспользоваться утилитой <code>avrdude</code> (не обязательно скачивать Arduino IDE). Чтобы вручную не вводить аргументы можно воспользоваться <code>Makefile</code> находящимся в репозитории:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">make flash
</code></pre></div><p>Данная команда исполняет следущую конструкцию:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">avrdude -c avrisp2 -P usb -p atmega328p -B 10 -F -U flash:w:grbl.hex:i
</code></pre></div><p>При использовании этого метода необходим AVR программатор для загрузки прошивки по AVR ISP порту, это не всегда удобно ввиду отсуствия проргамматора. В этом случае можно воспользоваться предустановленным в Arduino загрузчиком. Загрузчик это специальная программа записанная в память мк (работает аналогично BIOS), однако её может и не быть. Для прошивки таким способом достаточно иметь USB провод и саму плату Arduino. Это также позволяет удобнее загрузить скаченный hex-файл:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">avrdude -c arduino -p m328p -U flash:w:path/to/firmware.hex:i -P /dev/tty.usbserial-A804CL9D
</code></pre></div><p>Где <code>path/to/firmware.hex</code> – путь к файлу прошивки, а <code>/dev/tty.usbserial-A804CL9D</code> – serial порт подключенной Arduino.</p>
<h2 id="настройка-grbl">Настройка Grbl</h2>
<p>Итак, станок собран, контроллер подключен, прошивка залита. После подключения контроллера к компьютеру по USB и подключения к UART консоли, контроллер должен написать приветственную строку:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">Grbl 1.1h [&#39;$&#39; for help]
</code></pre></div><p>Введите <code>$</code> и нажмите <code>Enter</code>, чтобы Grbl вывел подсказку. На что Grbl должен вывести следующее:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H ~ ! ? ctrl-x]
</code></pre></div><p><code>$-команды</code> используются для <strong>просмотра или изменения параметров Grbl</strong>, а также <strong>запуска процедуры поиска начальной позиции</strong>.</p>
<p>Последние четыре команды (которые начинаются <strong>не со знака <code>$</code></strong>) – это команды управления в реальном времени, которые могут быть отправлены в любой момент, независимо от того, что в настоящее время делает Grbl. Они либо тут же меняют поведение работающего Grbl или сразу же выводят важные в реальном времени данные, например текущие координаты (aka DRO).</p>
<p>Я пришел к выводу, что для настройки станка, нужно понимать каждый параметр, поэтому настройку станка вижу пошаговым изучением параметров и, в случае необходимости, их изменением.</p>
<p>Ниже я аккумулировал и причесал информацию о параметрах со следующих источников: <a href="https://portal-pk.ru/arduino-forum/topic/90-nastroiki-grbl-v11-na-russkom.html">portal-pk.ru</a>, <a href="http://cnc-design.ru/proshivka-grbl-nastroika-parametrov.html">cnc-design.ru</a>, <a href="https://r13-project.ru/2020/02/28/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8-grbl-1-1f/">r13-project.ru</a>.</p>
<h3 id="параметры-grbl">Параметры Grbl</h3>
<p>Для просмотра параметров введите <code>$$</code> и нажмите <code>Enter</code>. Grbl ответит списком текущих системных настроек. В примере ниже настройки по умолчанию.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">$0=10 (Step pulse time, microseconds)
$1=25 (Step idle delay, milliseconds)
$2=0 (Step pulse invert, mask)
$3=0 (Step direction invert, mask)
$4=0 (Invert step enable pin, boolean)
$5=0 (Invert limit pins, boolean)
$6=0 (Invert probe pin, boolean)
$10=1 (Status report options, mask)
$11=0.010 (Junction deviation, millimeters)
$12=0.002 (Arc tolerance, millimeters)
$13=0 (Report in inches, boolean)
$20=0 (Soft limits enable, boolean)
$21=0 (Hard limits enable, boolean)
$22=0 (Homing cycle enable, boolean)
$23=0 (Homing direction invert, mask)
$24=25.000 (Homing locate feed rate, mm/min)
$25=500.000 (Homing search seek rate, mm/min)
$26=250 (Homing switch debounce delay, milliseconds)
$27=1.000 (Homing switch pull-off distance, millimeters)
$30=1000 (Maximum spindle speed, RPM)
$31=0 (Minimum spindle speed, RPM)
$32=0 (Laser-mode enable, boolean)
$100=250.000 (X-axis travel resolution, step/mm)
$101=250.000 (Y-axis travel resolution, step/mm)
$102=250.000 (Z-axis travel resolution, step/mm)
$110=500.000 (X-axis maximum rate, mm/min)
$111=500.000 (Y-axis maximum rate, mm/min)
$112=500.000 (Z-axis maximum rate, mm/min)
$120=10.000 (X-axis acceleration, mm/sec^2)
$121=10.000 (Y-axis acceleration, mm/sec^2)
$122=10.000 (Z-axis acceleration, mm/sec^2)
$130=200.000 (X-axis maximum travel, millimeters)
$131=200.000 (Y-axis maximum travel, millimeters)
$132=200.000 (Z-axis maximum travel, millimeters)
</code></pre></div><blockquote>
<p>Все параметры хранятся в энергонезависимой памяти мк – EEPROM. Так что они будут автоматически загружены при следующем включении вашей платы Arduino.</p>
</blockquote>
<p><code>$x=val</code> описывает отдельный параметр настроек, причем <code>val</code> это значение параметра.</p>
<blockquote>
<p>В предыдущих версиях Grbl каждый параметр имел после себя описание в круглых скобках. Но в Grbl, начиная с v1.1, этого, к сожалению, больше нет. Так было сделано, чтобы освободить flash-память для добавления новых возможностей, появившихся в v1.1. Однако, большинство хороших графических оболочек (GUI) добавляют для вас описания к параметрам, например используемая мной <code>CNCjs</code>.</p>
</blockquote>
<p>Для изменения параметра необходимо выполнить команду <code>$x=val</code>. Например, для изменения длины шагового импульса в микросекундах на значение 10мкс, нужно ввести <code>$0=10</code>, завершив команду нажатием клавищи <code>Enter</code>. Если все прошло успешно, Grbl ответит &lsquo;ok&rsquo;, новые настройки будут сохранены в EEPROM и будут использоваться вплоть до следующего их изменения.</p>
<p>Вы можете перепроверить, что Grbl получил и сохранил верное значение параметра, повторно введя команду <code>$$</code> для просмотра параметров из памяти.</p>
<h3 id="описание-параметров-grbl">Описание параметров Grbl</h3>
<blockquote>
<p>Примечание! Разница между <code>Grbl v0.9</code> и <code>Grbl v1.1</code> заключается только в том, что изменился вывод статуса командой <code>$10</code> и были добавлены команды для новых параметров <code>$30</code> / <code>$31</code> - максимальные/минимальные обороты шпинделя и <code>$32</code> - работа в режиме лазера. Все остальное - осталось без изменений.</p>
</blockquote>
<p><strong><code>$0</code> – Длительность шагового импульса, микросекунды</strong></p>
<p>Драйверы шаговых двигателей имеют ограничение на минимальную длительность шагового импульса. Уточните необходимое значение можно в документации на драйвер или перебором различных вариантов. Необходимо подобрать максимально короткий импульс, которые драйвер способен надежно распознавать. Если импульсы будут слишком длинные, вы можете столкнуться с проблемами при высоких скоростях подачи и большой частоте импульсов, возникающими из-за того, что идущие подряд импульсы начнут перекрывать друг друга. Рекомендуется использовать длительности в районе 10 микросекунд, что является значением по-умолчанию.</p>
<p><strong><code>$1</code> – Задержка отключения двигателей, миллисекунды</strong></p>
<p>Параметр меняется от 0 до 255.</p>
<ul>
<li>0 — напряжение снимается сразу;</li>
<li>255 — напряжение не снимается никогда.</li>
</ul>
<p>Каждый раз, когда ваши шаговые двигатели заканчивают движение и останавливаются, Grbl делает задержку на указанный интервал времени перед отключением питания двигателей. Вы можете всегда держать двигатели включенными (с подачей питания для удержания текущего положения) установив значение этого параметра в максимально возможное значение, равное 255 миллисекунд.</p>
<p>Отключение призвано помочь для тех типов двигателей, которые не следует держать включенными в течении долгого периода времени без какой-либо работы. И еще, имейте в виду, что в процессе отключения некоторые драйверы шаговых двигателей не запоминают на каком микрошаге они остановились, из-за этого вы можете стать свидетелем <strong>пропуска шагов</strong> при отключении/включении двигателей. В этом случае просто держите двигатели всегда включенными, для этого выполните <code>$1=255</code>.</p>
<p><strong><code>$2</code> – Инверсия порта шаговых испульсов, маска</strong></p>
<p>Этот параметр управляет инверсией сигнала шаговых импульсов (вывод STEP). По-умолчанию, сигнал шагового импульса начинается в нормально-низком состоянии и переключается в высокое на период импульса. По истечении времени, заданного параметром <code>$0</code>, вывод переключается обратно в низкое состояние, вплоть до следующего испульса. В режиме инверсии, шаговый импульс переключается из нормально-высокого в низкое на период импульса, а потом возвращается обратно в высокое состояние. Большинству пользователей не требуется менять значение этого параметра, но это может оказаться полезным, если конкретные драйверы ШД этого требуют.</p>
<p>Данный параметр задается по следующей маске:</p>
<table>
<thead>
<tr>
<th align="left">Значение</th>
<th align="left">Маска</th>
<th align="left">Ось X</th>
<th align="left">Ось Y</th>
<th align="left">Ось Z</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0</td>
<td align="left">000</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">001</td>
<td align="left">+</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">010</td>
<td align="left">-</td>
<td align="left">+</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">011</td>
<td align="left">+</td>
<td align="left">+</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">100</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">101</td>
<td align="left">+</td>
<td align="left">-</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">110</td>
<td align="left">-</td>
<td align="left">+</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">111</td>
<td align="left">+</td>
<td align="left">+</td>
<td align="left">+</td>
</tr>
</tbody>
</table>
<p><strong><code>$3</code> – Инверсия порта направления, маска</strong></p>
<p>Этот параметр инвертирует сигнал направления для каждой из осей (вывод DIR). По-умолчанию, Grbl предполагает, что ось движется в положительном направлении, когда уровень сигнала направления низкий, и в отрицательном - когда высокий. Часто оси в некоторых станках движутся не так. Этот параметр изменит инвертирует сигнал направления для тех осей, что движутся в обратную сторону.</p>
<blockquote>
<p>Положительное направление, когда значение перемещения по осям растёт.
Например: X=1..2..3..4..5</p>
</blockquote>
<p>Данный параметр задается по той же маске, что и <code>$2</code>.</p>
<p><strong><code>$4</code> – Инверсия сигнала включения шаговых двигателей, логический</strong></p>
<p>По умолчанию, высокий уровень сигнала включения шаговых двигателей (вывод ENABLE) соответствует выключению, а низкий - включению. Если ваша сборка требует обратного, просто инвертируйте сигнал, выполнив <code>$4=1</code>. Отключается с помощью <code>$4=0</code>.</p>
<blockquote>
<p>Может потребоваться перезапуск контроллера, чтобы изменения вступили в силу.</p>
</blockquote>
<p><strong><code>$5</code> – Инверсия входов концевых выключателей, логический</strong></p>
<p>По умолчанию, входы концевых выключателей подтягиваются к питанию встроенным резистором подтяжки Arduino. Когда сигнал на входе принимает низкий уровень, Grbl рассматривает это как срабатывание выключателя. Для противоположного поведения, просто инвертируйте входы, введя $5=1. Отключается командой $5=0. Может потребоваться перезапуск контроллера, чтобы изменения вступили в силу.</p>
<p>Если вы инвертируете входы концевых выключателей, потребуется внешний резистор подтяжки к земле, чтобы предотвратить перегрузку по току и сгоранию входа.</p>
<p><strong><code>$6</code> – Инверсия входа контактного датчика, логический</strong></p>
<p>По умолчанию, вход контактного датчика подтягивается к питанию встроенным резистором подтяжки Arduino. Когда сигнал на входе принимает низкий уровень, Grbl рассматривает это как срабатывание датчика. Для противоположного поведения, просто инвертируйте вход контактного датчика, введя <code>$6=1</code>. Отключается командой <code>$6=0</code>.</p>
<blockquote>
<p>Может потребоваться перезапуск контроллера, чтобы изменения втупили в силу.</p>
</blockquote>
<p>Если вы инвертируете вход контактного датчика, потребуется внешний резистор подтяжки к земле, чтобы предотвратить перегрузку по току и сгоранию входа.</p>
<p><strong><code>$10</code> – Отчет состояния, маска</strong></p>
<p>Параметр определяет какие данные реального времени вернет Grbl, когда пользователь запрашивает статус командой <code>?</code>.</p>
<p>Эти данные включают в себя текущее состояние, текущие координаты, текущую скорость подачи, значения на входах, текущие переопределенные значения, состояния буферов, и номер выполняемой команды G-кода (если было включено при компиляции).</p>
<p>По-умолчанию новая реализация вывода отчета в <code>Grbl v1.1</code> включает в себя вывод информации практически обо всем в стандартном выводе статуса. Множество данных скрывается и выводятся только тогда, когда их значение меняется. Это существенно увеличивает производительность по сравнению со старым способом и позволяет значительно быстрее получать обновленные данные о станке, причем в большем объеме. Документация на интерфейс в общих чертах рассказывает, как это работает, хотя в основном она предназначена только для разработчиков графических интерфейсов GUI.</p>
<p>Для простоты и удобства, <code>Grbl v1.1</code> имеет всего две опции для данного параметра. Обе используюся пользователями и разработчиками в основном для отладочных целей. Текущие координаты могут быть настроены на вывод либо машинных координат <code>MPos</code>, либо рабочих <code>WPos</code>, но не обеих одновременно. Включение рабочих координат полезно в некоторых случаях при прямом управлении через последовательный порт, но машинные координаты необходимо использовать по-умолчанию. Может быть включен вывод информации об использования буфера в планировщике и приемнике последовательного порта Grbl. При этом показывается количество блоков или байт, доступных в соответствующем буфере. Это, нужно для оценки производительности Grbl при тестировании потоковых интерфейсов. Эту опцию (параметр = 2) по-умолчанию следует отключить.</p>
<p>Используйте таблицу ниже для определения включаемых/отключаемых параметров.</p>
<table>
<thead>
<tr>
<th align="left">Значение</th>
<th align="left">Обозначение</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0</td>
<td align="left">Тип координат <code>WPos</code></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">Тип координат <code>MPos</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Включен вывод буфера данных <code>Buf</code>, содержащий количество свободного места в буферах планировщика и приемника последовательного порта</td>
</tr>
</tbody>
</table>
<p>Просто сложите значения в строках, содержащих включаемые параметры и сохраните в Grbl полученное значение. Например, отчет, содержащий машинные координаты без данных о буфере соответствует параметру <code>$10=1</code>. Рабочие координаты и информация о буфере соответствуют параметру <code>$10=2</code>.</p>
<p><strong><code>$11</code> – Отклонение на стыках, мм</strong></p>
<p>Заданная величина отклонения на стыках, используется модулем управления ускорением для определения скорости перемещения через стыки отрезков запрограммированного в G-коде пути. Например, если путь в G-коде содержит острый выступ с углом в 10 градусов, и станок двигается к нему на максимальной скорости, данный параметр поможет определить насколько нужно притормозить, чтобы выполнить поворот без потери шагов.</p>
<p>Вычисление выполняется доволно сложным образом, но в целом, более высокие значение дают более высокую скорость прохождения углов, повышая риск потерять шаги и сбить позиционирование. Меньшие значение делают модуль управления более аккуратным и приводят к более аккуратной и медленной обработке углов. Так что, если вдруг столкнетесь с проблемой слишком быстрой обработкой углов, уменьшите значение параметра, чтобы заставить станок притормаживать перед прохождением углов. Если хотите, чтобы станок быстрее проходил через стыки, необходимо увеличить значение параметра.</p>
<p>Описание алгоритма обработки углов в Grbl, который учитывает скорость и величину угла на стыке можно прочитать на <a href="https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/">onehossshay.wordpress.com</a>, а также на <a href="http://blog.kyneticcnc.com/2018/10/computing-junction-deviation-for-marlin.html">blog.kyneticcnc.com</a>.</p>
<p><strong><code>$12</code> – Отклонение от дуги, мм</strong></p>
<p>Grbl выполняет круги, дуги и спирали G2/G3, разбивая их на множество крошечных отрезков таким образом, чтобы погрешность отклонения от дуги не превышала значения данного параметра. Скорее всего вам никогда не придется менять этот параметр, поскольку значение 0.002мм находится ниже разрешающей способности большинства станков с ЧПУ. Однако, если вы обнаружили, что ваши окружности слишком угловатые или прохождение по дуге выполняется слишком уж медленно, откорректируйте значение этого параметра. Меньшие значение дают лучшую точность, но могут снизить производительность из-за перегрузки Grbl огромным количеством мелких линий. И наоборот, более высокие значения приводят к меньше точности обработки, но могут повысыть скорость, поскольку Grbl придется иметь дело в меньшим количеством линий.</p>
<p>Отклонение от дуги определяется как максимальная длина перпендикуляра проведенного от отрезка, соединяющего концы дуги (он же хорда) до пересечения с точкой дуги. Используя основы геометрии мы вычисляем на отрезки какой длины нужно разбить дугу, чтобы погрешность не превышала заданное значение. Моделирование дуг данным способом замечательно в том смысле, что отрезки с точки зрения производительности получаются оптимальной длины, а точность никогда не теряется.</p>
<p><strong><code>$13</code> – Отчет в дюймах, логический</strong></p>
<p>Grbl в реальном времени выводит координаты текущей позиции, чтобы пользователь всегда имел представление, где в данный момент находится станок, а также параметры смещения начала координат и данные измерения (probing). По-умолчанию вывод идет в мм, но командой <code>$13=1</code> можно изменить значение параметра и переключить вывод на дюймы. <code>$13=0</code> возвращает вывод в мм.</p>
<p><strong><code>$20</code> – Мягкие границы, логический</strong></p>
<p>Мягкие границы это настройка безопасности, призванная помочь избежать перемещения за пределы допустимой области, которое может повлечь за собой поломку или разрушение оборудования. Она работает за счет информации о текущем положении и пределах допустимого перемещения по каждой из осей. Каждый раз, когда Grbl отправляется G-код движения, он проверяет не произойдет ли выход за пределы допустимой области. И в случае, если происходит нарушение границ, Grbl, где бы он ни находился, немедленно выполняет команду остановки подачи, останавливает шпиндель и охлаждение, а затем выдает сигнал аварии для индикации проблемы. Текущее положение при этом не сбрасывается, поскольку остановка происходит не в результате аварийного принудительного останова, как в случае с жесткими границами.</p>
<p>Мягкие границы требуют включения поддержки процедуры поиска начальной позициии (<code>$22</code>) и аккуратной настройки максимальных границ для перемещения, поскольку Grbl нужно знать где находятся допустимые границы. Работают они так: станок при получении команды <code>$H</code> ищет начальную точку, а далее при работе следит за рабочей координатой, и если контроллеру приходит команда, которая вынудит его выехать за эти границы, то станок прекратит обработку сформировав сигнал ошибки. Текущее положение при этом не сбрасывается. <code>$20=1</code> для включения, и <code>$20=0</code> для отключения.</p>
<p><strong><code>$21</code> – Жесткие границы, логический</strong></p>
<p>Жесткие границы в общих чертах работают также как и мягкие, но используют аппаратные выключатели. Как правило, вы подсоединяете концевые выключатели (механические, магнитные или оптические) в конце каждой из осей или в тех точках, достижение которых в процессе перемещения, как вы считаете, может привести к проблемам. Когда срабатывает выключатель, он приводит к немедленной остановке любого перемещения, останову охлаждения и шпинделя (если подключен), и переходу в аварийный режим, требующий от вас проверить станок и выполнить сброс контроллера.</p>
<p>Для использования жестких границ с Grbl, соответствующие выводы подтягиваются к питанию внутренним резистором, поэтому все, что от вас требуется - подключить нормально разомкнутый концевой выключатель между выводом и землей и задействовать жесткие границы командой <code>$21=1</code>, отключение – командой <code>$21=0</code>. Мы настоятельно рекомендуем озаботиться подавлением электических наводок и помех, способных повлиять на измерения. Если хотите проверять границы для обоих концов одной оси, просто подключите два выключателя параллельно между выводом и землей, чтобы срабатывание любого из них приводило к срабатыванию жесткой границы.</p>
<p>Необходимо иметь в виду, что срабатывание жестких границ рассматривается как исключительное событие, требующее немедленной остановки, и может приводить к потере шагов. Grbl не имеет обратной связи от станка о текущем положении, так что он не может гарантировать, что имеет представление о реальном месте нахождения. Так что, если произошло нарушение жестких границ, Grbl перейдет в аварийный режим, требуя проверить станок и выполнить сброс Grbl в целях безопасности.</p>
<blockquote>
<p>Для включения жестких границ потребуется по 2 концевых выключателя на каждую ось, для ограничения перемещения в двух крайних положениях. Концевые выключатели вешают парно на 1 вход концевых выключателей, при срабатывании любого из двух должна происходить остановка станка.</p>
</blockquote>
<p><strong><code>$22</code> – Поиск начальной позиции, логический</strong></p>
<p>Процедура поиска начальной позиции используется для аккуратного и точного поиска заранее известной точки станка каждый раз после включения Grbl между сеансами работы. Другими словами, вы всегда, в любой момент времени точно знаете где находитесь. Собирались ли вы только начать работу или перешли к следующей операции, а в это время отключилось электричество, в любом случае Grbl перезапустится и не будет знать свое текущее местоположение. При наличии начальной позиции, у вас всегда есть эталонная точка отсчета, так что все, что в этом случае требуется, это запустить процедуру поиска начальной точки и продолжить работу с того места, где остановились.</p>
<p>Для настройки процедуры поиска начальной позиции вам потребуется наличие надежно закрепленных концевых выключателей в некоторой точке, на которые нельзя наткнуться или сдвинуть, в противном случае точка отсчета может быть сбита. Обычно они устанавливаются в самых дальних точках в направлении +x, +y, +z на каждой из осей. Соедините концевые выключатели с соответствующими выводами и землей, так же как и концевые выключатели аппаратных границ и задействуйте поиск начальной позиции. Если интересно, то вы можете использовать граничные выключатели и для аппаратных границ, и для поиска начальной позиции.</p>
<p>По-умолчанию, процедура поиска начальной позиции Grbl сначала выполняет перемещение по оси Z в положительном направлении, чтобы освободить рабочую область, а затем выполняет одновременное перемещение по осям X и Y в положительном направлении. Для настройки точного поведения процедуры поиска начальной позиции имеются несколько параметров настройки (а также параметры компиляции), описанных ниже.</p>
<p>В файле <code>config.h</code> находятся множество других настроек, ориентированных на продвинутых пользователей. Вы можете отключить блокировку при старте, указать с каких осей начать процедуру поиска, в каком порядке по ним перемещаться, а также многое другое.</p>
<blockquote>
<p>Также следует отметить, что при задействованной процедуре поиска начальной позиции Grbl блокирует выполнение команд перемещения G-кода до выполнения поиска начальной позиции. Имеется в виду отсутствие перемещения по осям, пока не будет отключена блокировка (<code>$X</code>). Большинство, если не все контроллеры с ЧПУ, ведут себя аналогично, делается это, в основном, для безопасности, чтобы не позволить оператору допустить ошибку позиционирования.</p>
</blockquote>
<p>Поиск начальной позиции осуществляется при подаче команды <code>$H</code> контроллер. Поиск начинается с перемещения инструмента в положение увеличения координаты (или уменьшения см. параметр <code>$23</code>), пока не произойдет срабатывание концевого выключателя. По умолчанию в первую очередь в нулевую точку едет ось Z, а за ней оси X и Y. Если вы используете контроллер для лазерного гравера, то в исходном коде необходимо установить запрет поиска нулевой точки оси Z, так как этой оси нет, и контроллер не найдя концевого выключателя выдаст ошибку или зависнет.</p>
<p><strong><code>$23</code> – Инверсия направления начальной точки, маска</strong></p>
<p>По-умолчанию, Grbl предполагает, что концевые выключатели начальной точки находятся в положительном направлении, он выполняет сначала перемещение в положительном направлении по оси Z, затем в положительном направлении по осям X-Y, перед тем как точно определить начальную точку медленно перемещаясь назад и вперед около концевого выключателя. Если у вашего станка концевые выключатели находятся в отрицательном направлении, инверсия направлений начальной точки изменяет направление осей.</p>
<p>Она работает точно так же, как и инверсия порта шаговых импульсов или инверсии порта направления, все что вам нужно это указать значение из таблицы (см. параметр <code>$2</code>), указывающее какие оси нужно инвертировать для поиска в противоположном направлении.</p>
<p><strong><code>$24</code> – Скорость подачи при точном поиске начальной точки, мм/мин</strong></p>
<p>При поиске нулевой точки контроллер вначале перемещает оси на высокой подаче до срабатывания концевика. Затем делает откат на расстояние <code>$27</code> и уже на низкой скорости точно определяет координату, вторым касанием концевика. Данный параметр задает скорость перемещения инструмента после отката при точном определении координаты (низкая скорость).</p>
<p><strong><code>$25</code> – Скорость подачи при быстром поиске начальной точки, мм/мин</strong></p>
<p>Скорость поиска начальной точки - это начальная скорость с которой контроллер пытается найти концевые выключатели начальной точки.</p>
<p>Данную скорость следует подобрать так, чтобы перемещение выполнялось как можно быстрее и при этом концевой выключатель успевал обрабатываться контроллером.</p>
<p><strong><code>$26</code> – Подавление дребезга при поиске начальной точки, миллисекунд</strong></p>
<p>Когда срабатывают выключатели, некоторые из них в течении нескольких миллисекунд могут издавать электрический/механический шум приводящий к быстрому переключению сигнала между высоким и низким значениями, прежде чем значение зафиксируется. В основном это наблюдается у механических контактов, ввиду того, что контакт прижимается не сразу, а ещё немного пружинит.</p>
<p>Для решения данной проблемы нужно подавить дребезг сигнала либо аппаратно, за счет какой-нибудь фильтрации, либо программно, сделав небольшую задержку на время дребезга. Grbl будет делать короткую задержку, но только при поиске начальной точки на этапе ее точного определения. Установите значение задержки, достаточное, чтобы ваши выключатели обеспечивали устойчивый поиск начальной точки. Для большинства случаев подойдут значения 5-25 миллисекунд.</p>
<p>При срабатывании концевого выключателя (особенно механического), наблюдается шум на входе (поочередные всплески от того, что контакт не сразу прижимается, а еще немного пружинит). Что бы исключить данный шум из расчета ьребуется либо установка фильтра, либо програмная задержка, которая и задается этим параметром. Для большинства случаев требуемое значения 5-25 миллисекунд.</p>
<p><strong><code>$27</code> – Отъезд от начальной точки, мм</strong></p>
<p>При объединение датчиков жестких границ станка и концевых выключателей для поиска начальной точки, процедура поиска после завершения определения положения начальной точки выполняет перемещение от концевых выключателей на указанное расстояние. Другими словами, это предотвращает непреднамеренное срабатывание жестких границ по окончании процедуры поиска.</p>
<p><strong><code>$30</code> – Максимальные обороты шпинделя, Об/мин</strong></p>
<p>Задает обороты шпинделя, соответствующие максимальному напряжению на выходе ШИМ, равному 5В. Допускается задавать в программе и более высокие обороты шпинделя, но вывод ШИМ все равно не может быть больше 5В. По-умолчанию, Grbl строит линейную зависимость из 255 отсчетов между максимальными-минимальными оборотами шпинделя и напряжениями на выходе ШИМ из диапазона 5В-0.02В. Значение ШИМ, равное 0В, означает отключение шпинделя. В файле <code>config.h</code> есть дополнительные параметры, влияющие на это поведение.</p>
<p><strong><code>$31</code> – Минимальные обороты шпинделя, Об/мин</strong></p>
<p>Задает обороты шпинделя (или мощность лазера), соответствующие минимальному напряжению на выходе ШИМ, равному 0.02V (напряжение питания платы/256).</p>
<blockquote>
<p>0В означает полное отключение. В случае использования драйвера бесколлекторного мотора нужно произвести его калибровку, чтобы при ШИМ соотвествующим 0В он не работал, а при 0.2В уже работал, а максимальная мощность достигалась при соотвествии ШИМ максимальному напряжению питания.</p>
</blockquote>
<p><strong><code>$32</code> – Режим лазера, логический</strong></p>
<p>Если параметр отключен, то Grbl будет прерывать движение каждый раз, когда встречает команду изменения оборотов шпинделя <code>S</code>. Это стандартное поведение для фрезеровальных станков, формирующее некоторую паузу, чтобы шпиндель успел изменить скорость своего вращения.</p>
<p>Если включить данный параметр, то контроллер перейдет на режим управления лазером. Лазер подключается на тот же пине отвечающем за обороты шпинделя. В случае с лазером, делать остановки не нужно, иначе в точках изменения яркости будут наблюдаться более черные точки или полосы. Значение скважности ШИМ, отвечающего за управление оборотами шпинделя, будет меняться в процессе движения сразу же, без выполнения остановки.</p>
<blockquote>
<p>Обязательно прочтите руководство Grbl по работе в режиме лазера и документацию на ваш лазер перед включением данного режима. Лазеры очень опасны. Они многут мгновенно лишить вас зрения или стать причиной пожара. Grbl, как и указано в его GPL лицензии, не несет никакой ответственности за любой вред, нанесенный в результате использования данной программы.</p>
</blockquote>
<p><strong><code>$100, $101, $102</code> – [X,Y,Z] шагов/мм</strong></p>
<p>Данные параметры задают количество шагов, сделав которое ось сдвинется на 1мм.</p>
<p>Например шаговый двигатель имеет 200 шагов на 1 оборот, контроллер настроен на 16 микрошаг. Теперь допустим, что при вращении двигателя на 1 оборот инструмент переместился на 32мм, тогда имеем. 200 шагов умножить на 16 микрошаг – 3200 импульсов нужно подать на контроллер, что бы шаговый двигатель сделал 1 оборот, и переместил инструмент на 32мм. Значит на 1мм он сдвинется за 3200/32мм=100 шагов.</p>
<p>Для калибровки необходимо узнать текущую настройку количества микрошагов драйвере двигателя. А также произвести замер реального перемещения оси соотвестующего некоторому количеству шагов. Далее составив пропорцию между текущем параметром шагов/мм, реальным перемещением и расчетным перемещением мб расчитан новый корректный параметр шагов/мм.</p>
<blockquote>
<p>Использование больших значений микрошага (например, 16) может уменьшить крутящий момент вашего двигателя, так что используйте минимальное значение, обеспечивающее нужную точность перемещения по осям и удобные эксплутационные характеристики.</p>
</blockquote>
<p><strong><code>$110, $111, $112</code> – [X,Y,Z] Максимальная скорость, мм/мин</strong></p>
<p>Эти параметры задают максимальную скорость перемещения для каждой из осей. Контроллер при получении G-кода анализирует скорости указанные в нем, и если команда задает скорость выше данных значений, то он ограничивает скорость.</p>
<p>Каждая из осей имеет свою максимальную скорость, что полезно для ограничения скорости, как правило, более меденной оси Z. Самый просто способ найти нужные значения - тестировать каждую ось раз за разом немного увеличивая скорость и выполняя действие перемещения.</p>
<p>Например, для проверки оси X, отправьте Grbl команду вида <code>G0 X50</code> с расстоянием перемещения, достаточно большим для разгона до максимальной скорости. Максимальное значение будет достигнуто, когда ваш шаговый двигатель застопорится. Он будет издавать жужжащий звук, но ничего страшного с ним не случится. Задайте значение на 10-20% меньше обнаруженного, чтобы учесть износ, трение и массу вашей рабочей головки/инструмента. Повторите процесс для остальных осей.</p>
<blockquote>
<p>Эти значения также определяют максимальную скорость перемещения при выполненнии команды <code>G0</code>.</p>
</blockquote>
<p><strong><code>$120, $121, $122</code> – [X,Y,Z] Ускорение, мм/сек^2</strong></p>
<p>Эти параметры задают параметры ускорения в мм/сек за секунду. Попросту говоря, меньшее значение делает перемещения более плавными, в то время как большее приводит к боле резким движениям и достижению требуемой скорости подачи гораздо быстрее. Как и в случае максимальных скоростей, каждая из осей имеет свое собственное значение ускорения, которые независимы друг от друга. Это означает, что в случае многоосевого перемещения ускорение будет соответствовать самой медленной из движущихся осей.</p>
<p>И опять, как и в случает с максимальными скоростями, самый простой способ определить значение этих параметров - индивидуально протестировать каждую из осей, медленно увеличивая значения, пока мотор не застопорится. Завершите настройку сохранением значения на 10-20% меньшим от обнаруженного. Это позволит учесть износ, трение и инертность массы. Мы настоятельно рекомендуем вчерновую протестировать некоторое количество программ на G-коде, прежде чем окончательно остановиться на выборанных значениях. Иногда нагрузка на ваш станок может оказаться иной при одновременном перемещении по нескольким осям.</p>
<p><strong><code>$130, $131, $132</code> – [X,Y,Z] Максимальное перемещение, мм</strong></p>
<p>Эти параметры задают максимальную дистанцию перемещения в мм от одного конца каждой из осей до другого. Они имеет смысл только если вы задействовали мягкие границы (и поиск начальной точки), поскольку используются только модулем проверки мягких границ для определения выхода за пределы допустимой области в процессе перемещения. См. параметры <code>$20</code>, <code>$22</code>.</p>
<h2 id="мои-настройки">Мои настройки</h2>
<h3 id="система-координат">Система координат</h3>
<p>Для начала советую определить <strong>переднюю сторону</strong> станка. Это одна из сторон параллельных порталу. Затем в левом углу разместите начало координат. Потом вектора осей исходящие из него:</p>
<ul>
<li><code>вектор оси X</code> – ось расположенная на портале;</li>
<li><code>вектор оси Y</code> – ось по которой перемещается портал;</li>
<li><code>вектор оси Z</code> - ось рабочего инструмента, направлена вверх от рабочей поверхности (ноль будет в самом низком положении инструмента).</li>
</ul>
<p><img src="./images/hello_html_m33fd4f14.png" alt="image"></p>
<p>Такое расположение осей будет легко сопоставить с тем, которое вы будете использовать при моделировании изделий и составлении УП. А также в принципе позволит легко ориентироваться в координатах станка.</p>
<p>Это расположение осей также задекларировано стандартом DIN 66217, подробнее в <a href="./PG_0911_ru_ru-RU.pdf">этом руководстве</a>.</p>
<h3 id="настройка-алгоритма-поиска-домашней-точки">Настройка алгоритма поиска домашней точки</h3>
<p>По-правильному нужно установить концевики в максимальных положениях осей. Это позволит переместиться в нулевую точку без срабатывания концевых выключателей. Если это не так то, расположение концевых выключателей можно инвертировать использовав параметр <code>$23</code>. В этом случае нужно помнить про то, что, послав станок в начальную точку, он заденет концевой выключатель.</p>
<p>Тут нужно сделать ещё одно замечание: при инвертировании расположения концевых выключателей это смещает машинную систему координат относительно нуля, на заднное параметрами <code>$130</code>, <code>$131</code>, <code>$132</code> расстояния минус расстояние заданное параметром <code>$27</code>.</p>
<p>В нормальном состояннии домашняя точка определяемая концевыми выключателями находятся в нуле, а вся рабочая зона в отрицательном значении.</p>
<h3 id="мои-параметры">Мои параметры</h3>
<p>Я пришел к следующему набору параметров (показаны только отличиные от базовых значения):</p>
<p>Общие:</p>
<ul>
<li><code>$0=15</code> – длина импульса на шаговик, поставил как в документации к <code>PLC330</code>.</li>
<li><code>$1=255</code> – запрет на отключение двигателей. При тестах по расчету коэфициента <code>steps/mm</code> ось не останавливалась продолжая движение по энерции. Очевидно, что стандартных 25мс было недостаточно для остановки. Поэтому я выбрал никогда не снимать питание с двигателей, так пропало движение оси по энерции. Также на <code>PLC330</code> есть автоматическое снижение тока на двигателе до 300мА в случае отсуствия новых команд в течении нескольких секунд. Это сыграло на руку.</li>
<li><code>$3=3</code> – инвертировал движение по оси X и Y (вместо этого можно просто поменять подключение обмоток шаговых моторов на драйвере, но я сделал чтобы все по цветам было одинаково).</li>
<li><code>$4=1</code> – инвертировал пин <code>ENABLE</code>, тк в порту LPT нормальная логика (высокий уровень соотвествует включению и наоборот).</li>
<li><code>$5=1</code> – инвертировал пины концевиков, тк в порту LPT нормальная логика.</li>
<li><code>$10=1</code> – добавил в вывод машинные координаты.</li>
</ul>
<p>Работа с концевиками:</p>
<ul>
<li><code>$21=1</code> – включил аварийную остановку при срабатывании концевиков.</li>
<li><code>$22=1</code> – включил алгортим поиска начальной точки по концевикам.</li>
<li><code>$27=2</code> – увеличил отъезд от концевика на 2мм, тк рама немного изогнута и при алгоритме поиска нулевой точки, иногда срабатывал концевик по X.</li>
</ul>
<p>Линейные коэффициенты, скорости и границы:</p>
<ul>
<li><code>$100=78.353</code>, <code>$101=78.353</code>, <code>$102=1066.126</code> – задал количество шагов на 1 мм перемещения по осям X, Y, Z.</li>
<li><code>$110=1000</code>, <code>$111=1000</code> – увеличил скорость перемещения по осям X, Y до 1000mm/min.</li>
<li><code>$130=500</code>, <code>$131=990</code>, <code>$132=200</code> задал максимальные перемещения по всем осям.</li>
</ul>
<h2 id="эксплуатация-grbl">Эксплуатация Grbl</h2>
<ol>
<li><a href="https://cnc-tex.ru/news/12/ustanovka-grbl-11-na-arduino-uno-osnovy-raboty-v-programme.html">cnc-tex.ru</a></li>
<li><a href="https://habr.com/ru/post/432818/">habr.com</a></li>
<li><a href="https://3dtoday.ru/blogs/mef78/cnc-mill-cyclone-pcb-factory-electronics-setup-the-firmware-and-a-litt">3dtoday.ru</a></li>
</ol>

            </div>

            <div class="tags">
                 
                <ul class="flat">
                    
                    <li><a href="/tags/ru">ru</a></li>
                    
                    <li><a href="/tags/cnc">cnc</a></li>
                    
                    <li><a href="/tags/diy">diy</a></li>
                    
                </ul>
                 
            </div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'urpylka';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the </a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
    </div>
    <div class="footer wrapper">
	<nav class="nav">
		<div>2021  © Artem Smirnov |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div><script>feather.replace()</script>
</body>

</html>